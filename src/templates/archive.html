{% extends "base.html" %}

{% block title %}Media Archive - Add to Database{% endblock %}
{% block header_subtitle %}M E D I A   A R C H I V E{% endblock %}

{% block extra_styles %}
.container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 400px 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background-color: #2b2b2b;
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h2 {
            margin-top: 0;
            color: #4a9eff;
            font-size: 1.2em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        
        /* Drop Zone */
        .drop-zone {
            border: 3px dashed #4a9eff;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .drop-zone.dragover {
            background-color: #1a3a5a;
            border-color: #6ac3ff;
        }
        
        .drop-zone:hover {
            background-color: #333;
        }
        
        .drop-zone-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        /* Status Message Container */
        #statusMessage {
            min-height: 50px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        #statusMessage .status-message {
            width: 100%;
        }
        
        /* Queue List */
        .queue-list {
            max-height: 400px;
            overflow-y: auto;
            background-color: #1a1a1a;
            border-radius: 4px;
            padding: 10px;
        }
        
        .queue-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #2b2b2b;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .queue-item:hover {
            background-color: #3a3a3a;
        }
        
        .queue-item.active {
            background-color: #1a4a7a;
            border-left: 3px solid #4a9eff;
        }
        
        /* Video Preview */
        .video-preview {
            width: 100%;
            max-height: 300px;
            background-color: #000;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .thumbnail-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        
        .thumbnail-grid img {
            max-width: 80%;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .thumbnail-grid img:hover {
            transform: scale(1.05);
        }
        
        /* Buttons */
        button {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        
        .btn-danger {
            background-color: #d9534f;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #c9433f;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #1a1a1a;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4a9eff;
            transition: width 0.3s;
            text-align: center;
            color: white;
            font-size: 0.8em;
            line-height: 20px;
        }
        
        /* Status Messages */
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .status-info {
            background-color: #1a4a7a;
            border-left: 4px solid #4a9eff;
        }
        
        .status-success {
            background-color: #2a5a2a;
            border-left: 4px solid #5cb85c;
        }
        
        .status-processing {
            background-color: #4a4a2a;
            border-left: 4px solid #f0ad4e;
        }
        
        .status-error {
            background-color: #5a2a2a;
            border-left: 4px solid #d9534f;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .action-buttons button {
            flex: 1;
        }
{% endblock %}

{% block cart_icon %}{% endblock %}

{% block content %}
<div class="container">
    <div class="main-layout">
        <!-- Left Panel: Queue -->
        <div class="panel">
            <h2>Processing Queue ({{ total_items }})</h2>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <p><strong>Drag & Drop Files Here</strong></p>
                    <p>or click to browse</p>
                    <input type="file" id="fileInput" multiple accept="video/*,image/*" style="display: none;">
                </div>
                
                <div id="statusMessage"></div>
                
                <div class="queue-list" id="queueList">
                    {% if queue %}
                        {% for file_id in queue %}
                        <div class="queue-item {% if loop.index0 == current_index %}active{% endif %}" 
                             data-index="{{ loop.index0 }}" 
                             onclick="loadQueueItem({{ loop.index0 }})">
                            {{ loop.index }}. {{ processed_files.get(file_id, {}).get('file_name', file_id) }}
                        </div>
                        {% endfor %}
                    {% else %}
                        <p style="text-align: center; color: #888;">No files in queue</p>
                    {% endif %}
                </div>
                
                <div class="action-buttons" style="margin-top: 25px;">
                    <button class="btn-secondary" onclick="clearQueue()">Clear All</button>
                </div>
                
                <div class="action-buttons" style="margin-top: 15px;">
                    <button type="button" class="btn-secondary" onclick="skipItem()">Remove Current</button>
                    <button type="button" id="saveButton" class="btn-primary" onclick="document.getElementById('metadataForm').requestSubmit()" disabled>Save to Database</button>
                </div>
            </div>
            
            <!-- Center Panel: Metadata Form -->
            <div class="panel">
                <h2>Media Metadata</h2>
                
                <div id="progressContainer" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar">0%</div>
                    </div>
                    <p id="progressText" style="text-align: center; color: #888;">Processing...</p>
                </div>
                
                <form id="metadataForm">
                    <!-- Read-only fields -->
                    <div class="form-group">
                        <label>File ID</label>
                        <input type="text" id="file_id" name="file_id" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Name</label>
                        <input type="text" id="file_name" name="file_name" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Path</label>
                        <input type="text" id="file_path" name="file_path" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Type</label>
                        <input type="text" id="file_type" name="file_type" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Resolution</label>
                        <input type="text" id="file_resolution" name="file_resolution" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Format</label>
                        <input type="text" id="file_format" name="file_format" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Duration (seconds)</label>
                        <input type="text" id="file_duration" name="file_duration" readonly>
                    </div>
                    
                    <hr style="border-color: #444; margin: 20px 0;">
                    
                    <!-- Editable fields -->
                    <div class="form-group">
                        <label>Source *</label>
                        <input type="text" id="source" name="source" required placeholder="e.g., ig, apod, metart">
                    </div>
                    
                    <div class="form-group">
                        <label>Source ID *</label>
                        <input type="text" id="source_id" name="source_id" required placeholder="e.g., ig_user">
                    </div>
                    
                    <div class="form-group">
                        <label>Genre *</label>
                        <select id="genre" name="genre" required>
                            <option value="">-- Select Genre --</option>
                            {% for g in genres %}
                            <option value="{{ g }}">{{ g }}</option>
                            {% endfor %}
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Subject *</label>
                        <input type="text" id="subject" name="subject" required placeholder="e.g., landscape, portrait, technology">
                    </div>
                    
                    <div class="form-group">
                        <label>Category *</label>
                        <input type="text" id="category" name="category" required placeholder="e.g., nature, urban, abstract">
                    </div>
                    
                    <div class="form-group">
                        <label>Setting *</label>
                        <input type="text" id="setting" name="setting" required placeholder="e.g., outdoor, studio, urban">
                    </div>
                    
                    <div class="form-group">
                        <label>Lighting *</label>
                        <input type="text" id="lighting" name="lighting" required placeholder="e.g., natural, studio, low-key">
                    </div>
                    
                    <div class="form-group">
                        <label>Tags (comma-separated) *</label>
                        <textarea id="tags" name="tags" required placeholder="sunset, ocean, peaceful"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>Captions *</label>
                        <textarea id="captions" name="captions" required placeholder="Detailed description of the media"></textarea>
                    </div>
                </form>
            </div>
            
            <!-- Right Panel: Preview -->
            <div class="panel">
                <h2>Preview</h2>
                
                <div id="videoContainer" style="display: none;">
                    <video id="videoPreview" class="video-preview" controls>
                        <source id="videoSource" src="" type="video/mp4">
                        Your browser does not support video playback.
                    </video>
                    
                    <button class="btn-secondary" onclick="generateThumbnails()" style="width: 100%; margin-bottom: 10px;">
                        Thumbnail Current Frame
                    </button>
                    
                    <div id="thumbnailGrid" class="thumbnail-grid"></div>
                </div>
                
                <div id="imageContainer" style="display: none;">
                    <img id="imagePreview" style="width: 100%; border-radius: 4px;" alt="Image preview">
                </div>
                
                <div id="noPreview" style="text-align: center; padding: 40px; color: #888;">
                    <p>No preview available</p>
                    <p style="font-size: 0.9em;">Select a file from the queue</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let currentQueue = {{ queue|tojson }};
        let currentIndex = {{ current_index }};
        let processedFiles = {{ processed_files|tojson }};
        
        // Show processing message IMMEDIATELY after variables are initialized
        const processingMsg = sessionStorage.getItem('processingMessage');
        if (processingMsg && currentQueue.length > 0) {
            // Use showStatus to ensure consistent behavior and protection
            showStatus(processingMsg, 'processing');
        }
        
        // Helper function to get current file_id from queue
        function getCurrentFileId() {
            if (currentIndex >= 0 && currentIndex < currentQueue.length) {
                return currentQueue[currentIndex];
            }
            return null;
        }
        
        const requiredFields = ['source', 'source_id', 'genre', 'subject', 'category', 'setting', 'lighting', 'tags', 'captions'];
        // Function to check if all required fields are filled
        function validateRequiredFields() {
            const saveButton = document.getElementById('saveButton');
            
            const allFilled = requiredFields.every(fieldId => {
                const field = document.getElementById(fieldId);
                return field && field.value && field.value.trim() !== '';
            });
            
            if (saveButton) {
                saveButton.disabled = !allFilled;
            }
        }
        
        // Add event listeners to all required fields
        document.addEventListener('DOMContentLoaded', function() {
            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', validateRequiredFields);
                    field.addEventListener('change', validateRequiredFields);
                }
            });
            
            // Initial validation
            validateRequiredFields();
        });
        
        // Drag and drop functionality
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            await handleFiles(files);
        });
        
        fileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            await handleFiles(files);
        });
        
        async function handleFiles(files) {
            if (files.length === 0) return;
            
            showStatus(`Uploading ${files.length} file(s)...`, 'info');
            
            try {
                const formData = new FormData();
                for (let file of files) {
                    formData.append('files', file);
                }
                
                const response = await fetch('/api/archive/upload_files', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Save current form data before reloading
                    await saveCurrentFormToCache();
                    
                    // Store processing message to persist across reload
                    sessionStorage.setItem('processingMessage', `Processing ${result.copied} file(s), please wait...`);
                    
                    // Reload and auto-select the last item (newly added)
                    const newQueueLength = currentQueue.length + result.copied;
                    window.location.href = window.location.pathname + '?index=' + (newQueueLength - 1);
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error uploading files: ' + error, 'error');
            }
        }
        
        async function saveCurrentFormToCache() {
            // Save current form values to cache before switching
            const fileId = getCurrentFileId();
            if (fileId && processedFiles[fileId]) {
                processedFiles[fileId].subject = document.getElementById('subject').value;
                processedFiles[fileId].genre = document.getElementById('genre').value;
                processedFiles[fileId].setting = document.getElementById('setting').value;
                processedFiles[fileId].category = document.getElementById('category').value;
                processedFiles[fileId].lighting = document.getElementById('lighting').value;
                processedFiles[fileId].captions = document.getElementById('captions').value;
                processedFiles[fileId].tags = document.getElementById('tags').value;
                processedFiles[fileId].source = document.getElementById('source')?.value || '';
                processedFiles[fileId].source_id = document.getElementById('source_id')?.value || '';
                
                // Persist to session immediately
                await fetch('/api/archive/save_processed', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({file_id: fileId, data: processedFiles[fileId]})
                });
            }
        }
        
        async function loadQueueItem(index, skipSave = false) {
            if (index >= currentQueue.length) return;
            
            // Save current form values before switching (unless we just saved to DB)
            if (!skipSave) {
                await saveCurrentFormToCache();
            }
            
            currentIndex = index;
            const fileId = currentQueue[index];
            
            // Check if file exists in cache and has metadata extracted
            const hasMetadata = processedFiles[fileId] && processedFiles[fileId].file_resolution;
            
            if (hasMetadata) {
                // Load cached data with full metadata
                const cached = processedFiles[fileId];
                
                // Populate form with cached data
                document.getElementById('file_id').value = cached.file_id;
                document.getElementById('file_name').value = cached.file_name;
                document.getElementById('file_path').value = cached.file_path;
                document.getElementById('file_type').value = cached.file_type;
                document.getElementById('file_resolution').value = cached.file_resolution || '';
                document.getElementById('file_format').value = cached.file_format || '';
                document.getElementById('file_duration').value = cached.file_duration || '';
                document.getElementById('subject').value = cached.subject || '';
                document.getElementById('genre').value = cached.genre || '';
                document.getElementById('setting').value = cached.setting || '';
                document.getElementById('category').value = cached.category || '';
                document.getElementById('lighting').value = cached.lighting || '';
                document.getElementById('captions').value = cached.captions || '';
                document.getElementById('tags').value = cached.tags || '';
                document.getElementById('source').value = cached.source || '';
                document.getElementById('source_id').value = cached.source_id || '';
                
                // Clear thumbnail grid
                document.getElementById('thumbnailGrid').innerHTML = '';
                
                // Show preview using the database path (with $DEPOT_ALL prefix)
                if (['mp4', 'mov', 'avi', 'mkv'].includes(cached.file_type)) {
                    showVideoPreview(cached.file_path);
                } else if (['jpg', 'jpeg', 'png'].includes(cached.file_type)) {
                    showImagePreview(cached.file_path);
                } else {
                    // Hide all previews for unsupported types
                    document.getElementById('videoContainer').style.display = 'none';
                    document.getElementById('imageContainer').style.display = 'none';
                    document.getElementById('noPreview').style.display = 'block';
                }
                
                // Don't show status here - it interferes with processing message
                // showStatus('Loaded cached data', 'info');
                
                // Update active queue item
                document.querySelectorAll('.queue-item').forEach((item, i) => {
                    item.classList.toggle('active', i === index);
                });
                
                // Validate fields to enable/disable save button
                validateRequiredFields();
                
                return;
            }
            
            // File uploaded but metadata not yet extracted
            const filePath = processedFiles[fileId].file_path;
            
            showStatus('Extracting metadata...', 'info');
            showProgress(0, 'Extracting metadata...');
            
            try {
                // Extract metadata
                const metaResponse = await fetch('/api/archive/extract_metadata', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({file_path: filePath})
                });
                
                const metaResult = await metaResponse.json();
                
                if (!metaResult.success) {
                    showStatus('Error extracting metadata: ' + metaResult.error, 'error');
                    return;
                }
                
                const metadata = metaResult.metadata;
                
                showProgress(50, 'Updating metadata...');
                
                // Update form fields with extracted metadata
                document.getElementById('file_id').value = fileId;
                document.getElementById('file_name').value = metadata.file_name;
                document.getElementById('file_path').value = filePath;
                document.getElementById('file_type').value = metadata.file_type;
                document.getElementById('file_resolution').value = metadata.file_resolution || '';
                document.getElementById('file_format').value = metadata.file_format || '';
                document.getElementById('file_duration').value = metadata.file_duration || '';
                
                // Load user-editable fields from cache (they should be empty for new files)
                const cachedSubject = (processedFiles[fileId].subject || '').trim();
                const metadataSubject = (metadata.subject || '').trim();
                const subjectValue = cachedSubject || metadataSubject || '';
                document.getElementById('subject').value = subjectValue;
                document.getElementById('genre').value = processedFiles[fileId].genre || '';
                document.getElementById('setting').value = processedFiles[fileId].setting || '';
                document.getElementById('category').value = processedFiles[fileId].category || '';
                document.getElementById('lighting').value = processedFiles[fileId].lighting || '';
                document.getElementById('captions').value = processedFiles[fileId].captions || '';
                document.getElementById('tags').value = processedFiles[fileId].tags || '';
                document.getElementById('source').value = processedFiles[fileId].source || '';
                document.getElementById('source_id').value = processedFiles[fileId].source_id || '';
                
                // Update processedFiles with extracted metadata
                processedFiles[fileId].file_resolution = metadata.file_resolution || '';
                processedFiles[fileId].file_format = metadata.file_format || '';
                processedFiles[fileId].file_duration = metadata.file_duration || '';
                if (!cachedSubject && metadataSubject) {
                    processedFiles[fileId].subject = metadataSubject;
                }
                
                // Save to session
                await fetch('/api/archive/save_processed', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({file_id: fileId, data: processedFiles[fileId]})
                });
                
                // Clear thumbnail grid for new file
                document.getElementById('thumbnailGrid').innerHTML = '';
                
                // Show preview using the database path (with $DEPOT_ALL)
                if (['mp4', 'mov', 'avi', 'mkv'].includes(metadata.file_type)) {
                    showVideoPreview(filePath);
                } else if (['jpg', 'jpeg', 'png'].includes(metadata.file_type)) {
                    showImagePreview(filePath);
                } else {
                    // Hide all previews for unsupported types
                    document.getElementById('videoContainer').style.display = 'none';
                    document.getElementById('imageContainer').style.display = 'none';
                    document.getElementById('noPreview').style.display = 'block';
                }
                
                hideProgress();
                //showStatus('File loaded successfully!', 'success');
                
                // Update active queue item
                document.querySelectorAll('.queue-item').forEach((item, i) => {
                    item.classList.toggle('active', i === index);
                });
                
                // Validate fields to enable/disable save button
                validateRequiredFields();
                
                // Clear processing message after file finishes loading
                if (sessionStorage.getItem('processingMessage')) {
                    sessionStorage.removeItem('processingMessage');
                    const statusContainer = document.getElementById('statusMessage');
                    if (statusContainer && statusContainer.querySelector('.status-processing')) {
                        statusContainer.innerHTML = '';
                    }
                }
                
            } catch (error) {
                hideProgress();
                showStatus('Error loading file: ' + error, 'error');
            }
        }
        
        function showVideoPreview(filePath) {
            document.getElementById('videoContainer').style.display = 'block';
            document.getElementById('imageContainer').style.display = 'none';
            document.getElementById('noPreview').style.display = 'none';
            
            const video = document.getElementById('videoPreview');
            const source = document.getElementById('videoSource');
            
            // Handle $DEPOT_ALL prefix - replace with empty to get relative path from depot root
            let relativePath = filePath.replace('$DEPOT_ALL/', '').replace('$DEPOT_ALL\\', '').replace(/\\/g, '/');
            
            // Construct URL for Flask static serving (static_folder = depot_local)
            source.src = `{{ url_for('static', filename='') }}${relativePath}`;
            video.load();
            
            showStatus('Video preview loaded. Click play or generate thumbnails.', 'info');
        }
        
        function showImagePreview(filePath) {
            document.getElementById('videoContainer').style.display = 'none';
            document.getElementById('imageContainer').style.display = 'block';
            document.getElementById('noPreview').style.display = 'none';
            
            const img = document.getElementById('imagePreview');
            
            // Handle $DEPOT_ALL prefix - replace with empty to get relative path from depot root
            let relativePath = filePath.replace('$DEPOT_ALL/', '').replace('$DEPOT_ALL\\', '').replace(/\\/g, '/');
            
            // Construct URL for Flask static serving
            img.src = `{{ url_for('static', filename='') }}${relativePath}`;
            
            showStatus('Image preview loaded', 'info');
        }
        
        async function generateThumbnails() {
            const fileId = getCurrentFileId();
            if (!fileId || !processedFiles[fileId]) {
                showStatus('No file loaded', 'error');
                return;
            }
            
            const filePath = processedFiles[fileId].file_path;
            
            // Convert $DEPOT_ALL path to absolute path for backend
            const absolutePath = filePath.replace('$DEPOT_ALL', '{{ depot_local }}').replace(/\\/g, '/');
            
            // Get current playhead position from video player
            const videoPlayer = document.getElementById('videoPreview');
            const currentTime = videoPlayer ? videoPlayer.currentTime : 0;
            
            try {
                showStatus('Capturing thumbnail...', 'info');
                
                const response = await fetch('/api/archive/generate_thumbnails', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        file_path: absolutePath,
                        current_time: currentTime
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const grid = document.getElementById('thumbnailGrid');
                    
                    grid.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; margin-top: 10px;">
                            <img src="/api/archive/serve_file?path=${encodeURIComponent(result.thumbnail)}" 
                                 style="max-width: 80%; height: auto; border: 2px solid #4a9eff; border-radius: 4px;"
                                 alt="Video thumbnail">
                            <p style="color: #888; font-size: 11px; margin-top: 5px;">
                                ${result.thumbnail.split('/').pop()}
                            </p>
                        </div>
                    `;
                    
                    showStatus('Thumbnail captured!', 'success');
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error, 'error');
            }
        }
        
        // Form submission
        document.getElementById('metadataForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Validate required fields
            const missingFields = [];
            for (const fieldId of requiredFields) {
                const element = document.getElementById(fieldId);
                if (!element.value || element.value.trim() === '') {
                    missingFields.push(fieldId);
                    element.style.borderColor = '#ff4444';
                } else {
                    element.style.borderColor = '#444';
                }
            }
            
            if (missingFields.length > 0) {
                showStatus(`Please fill in required fields: ${missingFields.join(', ')}`, 'error');
                return;
            }
            
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            try {
                showStatus('Saving to database...', 'info');
                
                const response = await fetch('/api/archive/submit', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus('Saved successfully!', 'success');
                    
                    // Remove saved item from queue
                    const fileId = getCurrentFileId();
                    currentQueue.splice(currentIndex, 1);
                    
                    // Remove from processed files cache
                    delete processedFiles[fileId];
                    
                    // Update session queue
                    await fetch('/api/archive/update_queue', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({queue: currentQueue})
                    });
                    
                    // Refresh queue display
                    refreshQueueDisplay();
                    
                    // Load next item or previous if at end
                    setTimeout(() => {
                        if (currentQueue.length === 0) {
                            showStatus('All items processed!', 'success');
                            window.location.reload();
                        } else {
                            // If we removed the last item, go to previous, otherwise stay at current index
                            const newIndex = currentIndex >= currentQueue.length ? currentQueue.length - 1 : currentIndex;
                            loadQueueItem(newIndex, true); // Skip save since we just saved
                        }
                    }, 1000);
                } else {
                    showStatus('Error saving: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error, 'error');
            }
        });
        
        // Note: Auto-save is handled by saveCurrentFormToCache() when switching items
        // and when submitting the form. No need for change event listeners.
        
        function skipItem() {
            if (currentQueue.length === 0) {
                showStatus('Queue is empty', 'info');
                return;
            }
            
            const fileId = getCurrentFileId();
            
            // Remove from queue
            currentQueue.splice(currentIndex, 1);
            
            // Remove from processed files cache
            if (fileId) {
                delete processedFiles[fileId];
            }
            
            // Update session
            fetch('/api/archive/update_queue', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({queue: currentQueue})
            }).then(() => {
                // Refresh queue display after successful update
                refreshQueueDisplay();
                
                // Move to next item or previous if at end
                if (currentQueue.length === 0) {
                    showStatus('Queue is empty', 'info');
                    window.location.reload();
                } else {
                    const newIndex = currentIndex >= currentQueue.length ? currentQueue.length - 1 : currentIndex;
                    loadQueueItem(newIndex, true); // Skip save since we're discarding this item
                }
            }).catch(error => {
                showStatus('Error updating queue: ' + error, 'error');
            });
        }
        
        function refreshQueueDisplay() {
            const queueList = document.getElementById('queueList');
            
            if (currentQueue.length === 0) {
                queueList.innerHTML = '<p style="text-align: center; color: #888;">No files in queue</p>';
                return;
            }
            
            queueList.innerHTML = '';
            currentQueue.forEach((fileId, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                if (index === currentIndex) {
                    div.classList.add('active');
                }
                div.setAttribute('data-index', index);
                div.onclick = () => loadQueueItem(index);
                const fileName = processedFiles[fileId] ? processedFiles[fileId].file_name : fileId;
                div.textContent = `${index + 1}. ${fileName}`;
                queueList.appendChild(div);
            });
        }
        
        async function clearQueue() {
            if (!confirm('Clear entire queue?')) return;
            
            try {
                await fetch('/api/archive/clear_queue', {method: 'POST'});
                window.location.reload();
            } catch (error) {
                showStatus('Error clearing queue: ' + error, 'error');
            }
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('statusMessage');
            if (!container) {
                console.error('statusMessage div not found');
                return;
            }
            
            // If a processing message exists in sessionStorage, don't replace it with info/success
            const processingMsg = sessionStorage.getItem('processingMessage');
            if (processingMsg && (type === 'info' || type === 'success')) {
                console.log('Preserving processing message, ignoring:', message);
                return; // Keep the processing message visible
            }
            
            container.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            // Only auto-clear info/success messages, not processing or error
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    // Only clear if the current message still has the same type AND no processing message exists
                    const currentMsg = container.querySelector('.status-message');
                    const stillProcessing = sessionStorage.getItem('processingMessage');
                    
                    // Don't clear if processing message is active
                    if (stillProcessing) {
                        return;
                    }
                    
                    // Clear the status message if it's still the same type
                    if (currentMsg && currentMsg.classList.contains(`status-${type}`)) {
                        container.innerHTML = '';
                    }
                }, 10000);
            }
            // processing and error messages never auto-clear
        }
        
        function showProgress(percent, text) {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressBar').textContent = Math.round(percent) + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        
        // Auto-load first item if queue exists
        if (currentQueue.length > 0 && currentIndex < currentQueue.length) {
            loadQueueItem(currentIndex);
        }
    </script>
</div>
{% endblock %}

{% block extra_scripts %}{% endblock %}
