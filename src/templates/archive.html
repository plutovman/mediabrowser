{% extends "base.html" %}

{% block title %}Media Archive - Add to Database{% endblock %}
{% block header_subtitle %}M E D I A   A R C H I V E{% endblock %}

{% block extra_styles %}
.container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 400px 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background-color: #2b2b2b;
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h2 {
            margin-top: 0;
            color: #4a9eff;
            font-size: 1.2em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        
        /* Drop Zone */
        .drop-zone {
            border: 3px dashed #4a9eff;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .drop-zone.dragover {
            background-color: #1a3a5a;
            border-color: #6ac3ff;
        }
        
        .drop-zone:hover {
            background-color: #333;
        }
        
        .drop-zone-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        /* Queue List */
        .queue-list {
            max-height: 400px;
            overflow-y: auto;
            background-color: #1a1a1a;
            border-radius: 4px;
            padding: 10px;
        }
        
        .queue-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #2b2b2b;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .queue-item:hover {
            background-color: #3a3a3a;
        }
        
        .queue-item.active {
            background-color: #1a4a7a;
            border-left: 3px solid #4a9eff;
        }
        
        /* Form Fields */
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        .form-group input:disabled {
            background-color: #2a2a2a;
            color: #888;
        }
        
        .form-group textarea {
            min-height: 40px;
            resize: vertical;
        }
        
        /* Video Preview */
        .video-preview {
            width: 100%;
            max-height: 300px;
            background-color: #000;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .thumbnail-grid img {
            width: 100%;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .thumbnail-grid img:hover {
            transform: scale(1.05);
        }
        
        /* Buttons */
        button {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background-color: #4a9eff;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: #3a8eef;
        }
        
        .btn-primary:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background-color: #555;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #666;
        }
        
        .btn-danger {
            background-color: #d9534f;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #c9433f;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #1a1a1a;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4a9eff;
            transition: width 0.3s;
            text-align: center;
            color: white;
            font-size: 0.8em;
            line-height: 20px;
        }
        
        /* Status Messages */
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .status-info {
            background-color: #1a4a7a;
            border-left: 4px solid #4a9eff;
        }
        
        .status-success {
            background-color: #2a5a2a;
            border-left: 4px solid #5cb85c;
        }
        
        .status-error {
            background-color: #5a2a2a;
            border-left: 4px solid #d9534f;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .action-buttons button {
            flex: 1;
        }
{% endblock %}

{% block cart_icon %}{% endblock %}

{% block content %}
<div class="container">
    <div class="main-layout">
        <!-- Left Panel: Queue -->
        <div class="panel">
            <h2>Processing Queue ({{ total_items }})</h2>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <p><strong>Drag & Drop Files Here</strong></p>
                    <p>or click to browse</p>
                    <input type="file" id="fileInput" multiple accept="video/*,image/*" style="display: none;">
                </div>
                
                <div class="queue-list" id="queueList">
                    {% if queue %}
                        {% for file in queue %}
                        <div class="queue-item {% if loop.index0 == current_index %}active{% endif %}" 
                             data-index="{{ loop.index0 }}" 
                             onclick="loadQueueItem({{ loop.index0 }})">
                            {{ loop.index }}. {{ file.split('/')[-1] }}
                        </div>
                        {% endfor %}
                    {% else %}
                        <p style="text-align: center; color: #888;">No files in queue</p>
                    {% endif %}
                </div>
                
                <div class="action-buttons" style="margin-top: 15px;">
                    <button class="btn-secondary" onclick="clearQueue()">Clear All</button>
                </div>
                
                <div class="action-buttons" style="margin-top: 15px;">
                    <button type="button" class="btn-secondary" onclick="skipItem()">Remove Current</button>
                    <button type="button" id="saveButton" class="btn-primary" onclick="document.getElementById('metadataForm').requestSubmit()" disabled>Save to Database</button>
                </div>
            </div>
            
            <!-- Center Panel: Metadata Form -->
            <div class="panel">
                <h2>Media Metadata</h2>
                
                <div id="statusMessage"></div>
                
                <div id="progressContainer" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar">0%</div>
                    </div>
                    <p id="progressText" style="text-align: center; color: #888;">Processing...</p>
                </div>
                
                <form id="metadataForm">
                    <!-- Read-only fields -->
                    <div class="form-group">
                        <label>File ID</label>
                        <input type="text" id="file_id" name="file_id" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Name</label>
                        <input type="text" id="file_name" name="file_name" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Path</label>
                        <input type="text" id="file_path" name="file_path" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Type</label>
                        <input type="text" id="file_type" name="file_type" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Resolution</label>
                        <input type="text" id="file_resolution" name="file_resolution" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Format</label>
                        <input type="text" id="file_format" name="file_format" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label>File Duration (seconds)</label>
                        <input type="text" id="file_duration" name="file_duration" readonly>
                    </div>
                    
                    <hr style="border-color: #444; margin: 20px 0;">
                    
                    <!-- Editable fields -->
                    <div class="form-group">
                        <label>Source *</label>
                        <input type="text" id="source" name="source" required placeholder="e.g., ig, apod, metart">
                    </div>
                    
                    <div class="form-group">
                        <label>Source ID *</label>
                        <input type="text" id="source_id" name="source_id" required placeholder="e.g., ig_user">
                    </div>
                    
                    <div class="form-group">
                        <label>Genre *</label>
                        <select id="genre" name="genre" required>
                            <option value="">-- Select Genre --</option>
                            {% for g in genres %}
                            <option value="{{ g }}">{{ g }}</option>
                            {% endfor %}
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Subject *</label>
                        <input type="text" id="subject" name="subject" required placeholder="e.g., landscape, portrait, technology">
                    </div>
                    
                    <div class="form-group">
                        <label>Category *</label>
                        <input type="text" id="category" name="category" required placeholder="e.g., nature, urban, abstract">
                    </div>
                    
                    <div class="form-group">
                        <label>Setting *</label>
                        <input type="text" id="setting" name="setting" required placeholder="e.g., outdoor, studio, urban">
                    </div>
                    
                    <div class="form-group">
                        <label>Lighting *</label>
                        <input type="text" id="lighting" name="lighting" required placeholder="e.g., natural, studio, low-key">
                    </div>
                    
                    <div class="form-group">
                        <label>Tags (comma-separated) *</label>
                        <textarea id="tags" name="tags" required placeholder="sunset, ocean, peaceful"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>Captions *</label>
                        <textarea id="captions" name="captions" required placeholder="Detailed description of the media"></textarea>
                    </div>
                </form>
            </div>
            
            <!-- Right Panel: Preview -->
            <div class="panel">
                <h2>Preview</h2>
                
                <div id="videoContainer" style="display: none;">
                    <video id="videoPreview" class="video-preview" controls>
                        <source id="videoSource" src="" type="video/mp4">
                        Your browser does not support video playback.
                    </video>
                    
                    <button class="btn-secondary" onclick="generateThumbnails()" style="width: 100%; margin-bottom: 10px;">
                        Thumbnail Current Frame
                    </button>
                    
                    <div id="thumbnailGrid" class="thumbnail-grid"></div>
                </div>
                
                <div id="imageContainer" style="display: none;">
                    <img id="imagePreview" style="width: 100%; border-radius: 4px;" alt="Image preview">
                </div>
                
                <div id="noPreview" style="text-align: center; padding: 40px; color: #888;">
                    <p>No preview available</p>
                    <p style="font-size: 0.9em;">Select a file from the queue</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let currentQueue = {{ queue|tojson }};
        let currentIndex = {{ current_index }};
        let currentCopyId = null;
        let processedFiles = {{ processed_files|tojson }};
        
        const requiredFields = ['source', 'source_id', 'genre', 'subject', 'category', 'setting', 'lighting', 'tags', 'captions'];
        // Function to check if all required fields are filled
        function validateRequiredFields() {
            const saveButton = document.getElementById('saveButton');
            
            const allFilled = requiredFields.every(fieldId => {
                const field = document.getElementById(fieldId);
                return field && field.value && field.value.trim() !== '';
            });
            
            if (saveButton) {
                saveButton.disabled = !allFilled;
            }
        }
        
        // Add event listeners to all required fields
        document.addEventListener('DOMContentLoaded', function() {
            //const requiredFields = ['source', 'source_id', 'genre', 'subject', 'category', 'setting', 'lighting', 'tags', 'captions'];
            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', validateRequiredFields);
                    field.addEventListener('change', validateRequiredFields);
                }
            });
            
            // Initial validation
            validateRequiredFields();
        });
        
        // Drag and drop functionality
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            await handleFiles(files);
        });
        
        fileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            await handleFiles(files);
        });
        
        async function handleFiles(files) {
            if (files.length === 0) return;
            
            showStatus(`Uploading ${files.length} file(s)...`, 'info');
            
            try {
                const formData = new FormData();
                for (let file of files) {
                    formData.append('files', file);
                }
                
                const response = await fetch('/api/archive/upload_files', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Save current form data before reloading
                    await saveCurrentFormToCache();
                    
                    showStatus(`Uploaded ${result.copied} file(s)`, 'success');
                    
                    // Reload and auto-select the last item (newly added)
                    const newQueueLength = currentQueue.length + result.copied;
                    window.location.href = window.location.pathname + '?index=' + (newQueueLength - 1);
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error uploading files: ' + error, 'error');
            }
        }
        
        async function saveCurrentFormToCache() {
            // Save current form values to cache before switching
            if (currentIndex >= 0 && currentIndex < currentQueue.length) {
                const currentFilePath = currentQueue[currentIndex];
                if (processedFiles[currentFilePath]) {
                    processedFiles[currentFilePath].subject = document.getElementById('subject').value;
                    processedFiles[currentFilePath].genre = document.getElementById('genre').value;
                    processedFiles[currentFilePath].setting = document.getElementById('setting').value;
                    processedFiles[currentFilePath].category = document.getElementById('category').value;
                    processedFiles[currentFilePath].lighting = document.getElementById('lighting').value;
                    processedFiles[currentFilePath].captions = document.getElementById('captions').value;
                    processedFiles[currentFilePath].tags = document.getElementById('tags').value;
                    processedFiles[currentFilePath].source = document.getElementById('source')?.value || '';
                    processedFiles[currentFilePath].source_id = document.getElementById('source_id')?.value || '';
                    
                    // Persist to session immediately
                    await fetch('/api/archive/save_processed', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({file_path: currentFilePath, data: processedFiles[currentFilePath]})
                    });
                }
            }
        }
        
        async function loadQueueItem(index) {
            if (index >= currentQueue.length) return;
            
            // Save current form values before switching
            await saveCurrentFormToCache();
            
            currentIndex = index;
            const filePath = currentQueue[index];
            
            // Check if file was already processed
            if (processedFiles[filePath]) {
                // Load cached data
                const cached = processedFiles[filePath];
                
                // Populate form with cached data
                document.getElementById('file_id').value = cached.file_id;
                document.getElementById('file_name').value = cached.file_name;
                document.getElementById('file_path').value = cached.file_path;
                document.getElementById('file_type').value = cached.file_type;
                document.getElementById('file_resolution').value = cached.file_resolution || '';
                document.getElementById('file_format').value = cached.file_format || '';
                document.getElementById('file_duration').value = cached.file_duration || '';
                document.getElementById('subject').value = cached.subject || '';
                document.getElementById('genre').value = cached.genre || '';
                document.getElementById('setting').value = cached.setting || '';
                document.getElementById('category').value = cached.category || '';
                document.getElementById('lighting').value = cached.lighting || '';
                document.getElementById('captions').value = cached.captions || '';
                document.getElementById('tags').value = cached.tags || '';
                document.getElementById('source').value = cached.source || '';
                document.getElementById('source_id').value = cached.source_id || '';
                
                // Show preview (use the copied file path)
                const copiedPath = cached.file_path.replace('$DEPOT_ALL', '{{ depot_local }}');
                if (['mp4', 'mov', 'avi', 'mkv'].includes(cached.file_type)) {
                    showVideoPreview(copiedPath);
                } else if (['jpg', 'jpeg', 'png'].includes(cached.file_type)) {
                    showImagePreview(copiedPath);
                }
                
                showStatus('Loaded cached data', 'info');
                
                // Update active queue item
                document.querySelectorAll('.queue-item').forEach((item, i) => {
                    item.classList.toggle('active', i === index);
                });
                
                return;
            }
            
            // File not yet processed - do full processing
            showStatus('Loading file...', 'info');
            showProgress(0, 'Extracting metadata...');
            
            try {
                // Extract metadata
                const metaResponse = await fetch('/api/archive/extract_metadata', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({file_path: filePath})
                });
                
                const metaResult = await metaResponse.json();
                
                if (!metaResult.success) {
                    showStatus('Error extracting metadata: ' + metaResult.error, 'error');
                    return;
                }
                
                const metadata = metaResult.metadata;
                
                showProgress(30, 'Copying file to repository...');
                
                // Copy file
                const copyResponse = await fetch('/api/archive/copy_file', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        source_path: filePath,
                        file_type: metadata.file_type
                    })
                });
                
                const copyResult = await copyResponse.json();
                
                if (!copyResult.success) {
                    showStatus('Error copying file: ' + copyResult.error, 'error');
                    return;
                }
                
                currentCopyId = copyResult.copy_id;
                
                // Poll for copy progress
                await pollCopyProgress(currentCopyId);
                
                // Populate form
                const fileId = 'MED' + Date.now() + Math.floor(Math.random() * 1000);
                document.getElementById('file_id').value = fileId;
                document.getElementById('file_name').value = metadata.file_name;
                document.getElementById('file_path').value = copyResult.dest_path_rel;
                document.getElementById('file_type').value = metadata.file_type;
                document.getElementById('file_resolution').value = metadata.file_resolution || '';
                document.getElementById('file_format').value = metadata.file_format || '';
                document.getElementById('file_duration').value = metadata.file_duration || '';
                
                // Use the actual destination path as the cache key (matches where file was moved)
                const actualFilePath = copyResult.dest_path_abs;

                //console.log('Copy result:', copyResult);
                //console.log('dest_path_rel:', copyResult.dest_path_rel);
                
                // Cache the processed data using the ORIGINAL queue path as key
                processedFiles[filePath] = {
                    file_id: fileId,
                    file_name: metadata.file_name,
                    file_path: copyResult.dest_path_rel,
                    file_type: metadata.file_type,
                    file_resolution: metadata.file_resolution || '',
                    file_format: metadata.file_format || '',
                    file_duration: metadata.file_duration || '',
                    subject: '',
                    genre: '',
                    setting: '',
                    category: '',
                    lighting: '',
                    captions: '',
                    tags: '',
                    source: '',
                    source_id: ''
                };
                
                // Save to session
                await fetch('/api/archive/save_processed', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({file_path: filePath, data: processedFiles[filePath]})
                });
                
                // Show preview using the actual file location
                if (['mp4', 'mov', 'avi', 'mkv'].includes(metadata.file_type)) {
                    showVideoPreview(actualFilePath);
                } else if (['jpg', 'jpeg', 'png'].includes(metadata.file_type)) {
                    showImagePreview(actualFilePath);
                }
                
                hideProgress();
                showStatus('File loaded successfully!', 'success');
                
                // Update active queue item
                document.querySelectorAll('.queue-item').forEach((item, i) => {
                    item.classList.toggle('active', i === index);
                });
                
            } catch (error) {
                hideProgress();
                showStatus('Error loading file: ' + error, 'error');
            }
        }
        
        async function pollCopyProgress(copyId) {
            return new Promise((resolve) => {
                const interval = setInterval(async () => {
                    try {
                        const response = await fetch(`/api/archive/copy_progress/${copyId}`);
                        const progress = await response.json();
                        
                        showProgress(30 + (progress.percent * 0.6), `Copying: ${progress.percent}%`);
                        
                        if (progress.status === 'complete') {
                            clearInterval(interval);
                            showProgress(100, 'Copy complete!');
                            resolve();
                        }
                    } catch (error) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 500);
            });
        }
        
        function showVideoPreview(filePath) {
            document.getElementById('videoContainer').style.display = 'block';
            document.getElementById('imageContainer').style.display = 'none';
            document.getElementById('noPreview').style.display = 'none';
            
            const video = document.getElementById('videoPreview');
            const source = document.getElementById('videoSource');
            
            // Normalize path to forward slashes
            const normalizedPath = filePath.replace(/\\/g, '/');
            
            // Get base media path (already has forward slashes from Python)
            const pathBaseMedia = '{{ path_base_media }}'.replace(/\\/g, '/');
            
            // Extract relative path by removing the base media prefix
            // This handles Windows drive letters (M:/depot/...) correctly
            let relativePath = normalizedPath;
            if (relativePath.startsWith(pathBaseMedia)) {
                relativePath = relativePath.substring(pathBaseMedia.length);
            }
            // Remove any leading slashes
            relativePath = relativePath.replace(/^\/+/, '');
            
            source.src = `{{ url_for('static', filename='') }}${relativePath}`;
            video.load();
            
            showStatus('Video preview loaded. Click play or generate thumbnails.', 'info');
        }
        
        function showImagePreview(filePath) {
            document.getElementById('videoContainer').style.display = 'none';
            document.getElementById('imageContainer').style.display = 'block';
            document.getElementById('noPreview').style.display = 'none';
            
            const img = document.getElementById('imagePreview');
            
            // Normalize path to forward slashes
            const normalizedPath = filePath.replace(/\\/g, '/');
            
            // Get base media path (already has forward slashes from Python)
            const pathBaseMedia = '{{ path_base_media }}'.replace(/\\/g, '/');
            
            // Extract relative path by removing the base media prefix
            // This handles Windows drive letters (M:/depot/...) correctly
            let relativePath = normalizedPath;
            if (relativePath.startsWith(pathBaseMedia)) {
                relativePath = relativePath.substring(pathBaseMedia.length);
            }
            // Remove any leading slashes
            relativePath = relativePath.replace(/^\/+/, '');
            
            img.src = `{{ url_for('static', filename='') }}${relativePath}`;
            
            showStatus('Image preview loaded', 'info');
        }
        
        async function generateThumbnails() {
            const filePath = currentQueue[currentIndex];
            
            // Get current playhead position from video player
            const videoPlayer = document.getElementById('videoPreview');
            const currentTime = videoPlayer ? videoPlayer.currentTime : 0;
            
            try {
                showStatus('Capturing thumbnail...', 'info');
                
                const response = await fetch('/api/archive/generate_thumbnails', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        file_path: filePath,
                        current_time: currentTime
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const grid = document.getElementById('thumbnailGrid');
                    
                    grid.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; margin-top: 10px;">
                            <img src="/api/archive/serve_file?path=${encodeURIComponent(result.thumbnail)}" 
                                 style="max-width: 80%; height: auto; border: 2px solid #4a9eff; border-radius: 4px;"
                                 alt="Video thumbnail">
                            <p style="color: #888; font-size: 11px; margin-top: 5px;">
                                ${result.thumbnail.split('/').pop()}
                            </p>
                        </div>
                    `;
                    
                    showStatus('Thumbnail captured!', 'success');
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error, 'error');
            }
        }
        
        // Form submission
        document.getElementById('metadataForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Validate required fields
            const requiredFields = [
                {id: 'genre', label: 'Genre'},
                {id: 'subject', label: 'Subject'},
                {id: 'category', label: 'Category'},
                {id: 'setting', label: 'Setting'},
                {id: 'lighting', label: 'Lighting'},
                {id: 'tags', label: 'Tags'},
                {id: 'captions', label: 'Captions'}
            ];
            
            const missingFields = [];
            for (const field of requiredFields) {
                const element = document.getElementById(field.id);
                if (!element.value || element.value.trim() === '') {
                    missingFields.push(field.label);
                    element.style.borderColor = '#ff4444';
                } else {
                    element.style.borderColor = '#444';
                }
            }
            
            if (missingFields.length > 0) {
                showStatus(`Please fill in required fields: ${missingFields.join(', ')}`, 'error');
                return;
            }
            
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            try {
                showStatus('Saving to database...', 'info');
                
                const response = await fetch('/api/archive/submit', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus('Saved successfully!', 'success');
                    
                    // Remove saved item from queue
                    const filePath = currentQueue[currentIndex];
                    currentQueue.splice(currentIndex, 1);
                    
                    // Remove from processed files cache
                    delete processedFiles[filePath];
                    
                    // Update session queue
                    await fetch('/api/archive/update_queue', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({queue: currentQueue})
                    });
                    
                    // Refresh queue display
                    refreshQueueDisplay();
                    
                    // Load next item or previous if at end
                    setTimeout(() => {
                        if (currentQueue.length === 0) {
                            showStatus('All items processed!', 'success');
                            window.location.reload();
                        } else {
                            // If we removed the last item, go to previous, otherwise stay at current index
                            const newIndex = currentIndex >= currentQueue.length ? currentQueue.length - 1 : currentIndex;
                            loadQueueItem(newIndex);
                        }
                    }, 1000);
                } else {
                    showStatus('Error saving: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error, 'error');
            }
        });
        
        // Auto-save editable fields to cache
        ['subject', 'genre', 'setting', 'captions', 'tags', 'category', 'lighting'].forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.addEventListener('change', async () => {
                    const filePath = currentQueue[currentIndex];
                    if (processedFiles[filePath]) {
                        processedFiles[filePath][fieldId] = field.value;
                        
                        // Save to session
                        await fetch('/api/archive/save_processed', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({file_path: filePath, data: processedFiles[filePath]})
                        });
                    }
                });
            }
        });
        
        function skipItem() {
            if (currentQueue.length === 0) {
                showStatus('Queue is empty', 'info');
                return;
            }
            
            const filePath = currentQueue[currentIndex];
            
            // Normalize path for comparison (convert backslashes to forward slashes)
            const normalizedPath = filePath.replace(/\\/g, '/');
            
            // Remove from queue
            currentQueue.splice(currentIndex, 1);
            
            // Remove from processed files cache - try both original and normalized paths
            delete processedFiles[filePath];
            delete processedFiles[normalizedPath];
            
            // Also check if the cached key is the absolute path
            const pathBaseMedia = '{{ path_base_media }}'.replace(/\\/g, '/');
            if (normalizedPath.startsWith(pathBaseMedia)) {
                delete processedFiles[normalizedPath];
            }
            
            // Update session
            fetch('/api/archive/update_queue', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({queue: currentQueue})
            }).then(() => {
                // Refresh queue display after successful update
                refreshQueueDisplay();
                
                // Move to next item or previous if at end
                if (currentQueue.length === 0) {
                    showStatus('Queue is empty', 'info');
                    window.location.reload();
                } else {
                    const newIndex = currentIndex >= currentQueue.length ? currentQueue.length - 1 : currentIndex;
                    loadQueueItem(newIndex);
                }
            }).catch(error => {
                showStatus('Error updating queue: ' + error, 'error');
            });
        }
        
        function refreshQueueDisplay() {
            const queueList = document.getElementById('queueList');
            
            if (currentQueue.length === 0) {
                queueList.innerHTML = '<p style="text-align: center; color: #888;">No files in queue</p>';
                return;
            }
            
            queueList.innerHTML = '';
            currentQueue.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                if (index === currentIndex) {
                    div.classList.add('active');
                }
                div.setAttribute('data-index', index);
                div.onclick = () => loadQueueItem(index);
                div.textContent = `${index + 1}. ${file.split('/').pop()}`;
                queueList.appendChild(div);
            });
        }
        
        async function clearQueue() {
            if (!confirm('Clear entire queue?')) return;
            
            try {
                await fetch('/api/archive/clear_queue', {method: 'POST'});
                window.location.reload();
            } catch (error) {
                showStatus('Error clearing queue: ' + error, 'error');
            }
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('statusMessage');
            container.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => container.innerHTML = '', 3000);
            }
        }
        
        function showProgress(percent, text) {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressBar').textContent = Math.round(percent) + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        
        // Auto-load first item if queue exists
        if (currentQueue.length > 0 && currentIndex < currentQueue.length) {
            loadQueueItem(currentIndex);
        }
    </script>
</div>
{% endblock %}

{% block extra_scripts %}{% endblock %}
